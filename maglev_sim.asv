function [x_next, sim_error]  = maglev_sim(Ts, x, u, params)

%This simulation will use the more complicated differential equations for a
%more realistic simulation

%This takes initial conditions and uses matlab numerical solvers to
%approximate the resultant yi, and dy at the end of each sensor cycle
%(at which point the controller would be updated with new values)

%x(1) = y1
%x(2) = dy1
%x(3) = y2
%x(4) = dy2

sim_error = false; 

%x_next follows the same logic

odefun = @(t, x) maglev_ode (t, x, u, params);

eventfun = @(t, x) maglev_events(t, x, params);

opts = odeset('RelTol',1e-6, 'AbsTol',1e-9, 'MaxStep', Ts/4, 'Events', eventfun);

[~, x_sol, ~, ~, ~] = ode45(odefun , [0 Ts], x, opts);

e = params.e; 

y1_cm = y1 * 100;
y2_cm = y2 * 100;

gap_cm = params.yc + y2_cm - y1_cm;

min_gap_cm = params.min_gap;



%Error feedback 
%if ~isempty(ie)

      %x_event = xe(1,:).';

    % EVENT 1 — puck–puck collision (fatal)
    if (gap_cm - min_gap_cm)<=0
        disp('puck collision');
        sim_error = true;
        x_next = x_sol(:, end).';
        return;
    end

    % EVENT 2 — lower puck hits y1 = 0
    if any(ie == 2)
        disp('lower bounce');
         = 0;
        if x_event(2) < 0
            x_event(2) = -e * x_event(2);
        end
    end

    % EVENT 3 — upper puck hits y2 = 0
    if any(ie == 3)
        disp('event3');
        x_event(3) = 0;
        if x_event(4) > 0
            x_event(4) = -e * x_event(4);
        end
    end

    %x_next = x_event;
    %return;
%end

% Below hardcodes a collision with the top or bottom, no springiness 
%is implemented as this is not a collision simulation, if you are colliding
%other than for initial conditions at rest, you have missed the point of
%controls class

x_next = x_sol(end, :).';  % final state approximations after Ts

end
